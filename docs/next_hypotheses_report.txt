======================================================================
NEXT HYPOTHESES AND VERIFICATION METHODS
======================================================================

## Current State Summary

- Total samples: 432
- FDM dominance: 99.5%
- Spectral wins: 2 cases
- Spectral win conditions: α ≤ 0.1, stiffness < 0.2708

## Identified Gaps

1. [HIGH] FDM wins 99.5% - Is this due to spectral instability or genuine superiority?
   Related: H1, H2, H3
2. [HIGH] Only one IC tested (T₀ = 1-r²). Results may not generalize.
   Related: H4, H5
3. [MEDIUM] λ=0.1 fixed. Unknown how results change with different λ.
   Related: H6
4. [HIGH] Spectral rarely wins. Unclear if it's error or instability.
   Related: H2, H7
5. [MEDIUM] Limited grid parameter combinations (3×3×3). May miss optimal regions.
   Related: H8

## Proposed Hypotheses


### HIGH Priority

**[H1] Spectral solver fails due to numerical instability from threshold-based χ, not accuracy issues**

Rationale: The threshold χ formula creates discontinuities that spectral methods handle poorly

Verification:
  1. Run spectral solver with very small dt (dt=0.0001)
  2. Check if solution remains bounded
  3. Compare error growth rate vs FDM
  4. Analyze Fourier coefficients for spurious modes

Expected: Spectral shows exponential error growth for α > 0.1

```python
# Test spectral stability
from solvers.spectral.cosine import CosineSpectral
import numpy as np

r = np.linspace(0, 1, 101)
T0 = 1 - r**2
solver = CosineSpectral()

for dt in [0.001, 0.0005, 0.0001]:
    T_hist = solver.solve(T0.copy(), r, dt, t_end=0.1, alpha=0.5)
    max_T = np.max(np.abs(T_hist))
    print(f"dt={dt}: max|T|={max_T:.2e}, stable={max_T < 10}")
```

**[H2] Spectral fails because nonlinear term is treated explicitly**

Rationale: CosineSpectral uses operator splitting with explicit nonlinear step

Verification:
  1. Examine spectral solver code for time-stepping scheme
  2. Implement semi-implicit or fully implicit variant
  3. Compare stability regions

Expected: Implicit treatment of χ improves spectral stability

```python
# Check current spectral implementation
# solvers/spectral/cosine.py line ~70-90
# Look for explicit vs implicit treatment of chi term
```

**[H4] With smoother IC (e.g., Gaussian), spectral may outperform FDM**

Rationale: Spectral methods excel for smooth solutions; T₀=1-r² has |T'|=2 at boundary

Verification:
  1. Add new IC: T₀ = exp(-10r²) (Gaussian, already implemented before)
  2. Add new IC: T₀ = cos(πr/2) (very smooth)
  3. Regenerate training data with multiple ICs
  4. Compare solver performance per IC

Expected: Spectral wins more often for smooth ICs with small gradients

```python
import numpy as np

def make_initial_gaussian(r):
    return np.exp(-10 * r**2)

def make_initial_cosine(r):
    return np.cos(np.pi * r / 2)

def make_initial_parabola(r):
    return 1 - r**2

# Compare max|dT/dr| for each IC
r = np.linspace(0, 1, 101)
dr = r[1] - r[0]

for name, ic_func in [("gaussian", make_initial_gaussian),
                       ("cosine", make_initial_cosine),
                       ("parabola", make_initial_parabola)]:
    T0 = ic_func(r)
    dTdr = np.gradient(T0, dr)
    print(f"{name}: max|dT/dr|={np.max(np.abs(dTdr)):.3f}")
```

**[H7] Spectral 'failures' are NaN/Inf (instability), not large but finite errors**

Rationale: Need to distinguish numerical blowup from poor accuracy

Verification:
  1. Run spectral for all parameter combinations
  2. Classify outcomes: stable+accurate, stable+inaccurate, unstable (NaN/Inf)
  3. Map instability regions in parameter space

Expected: Most spectral 'losses' are due to NaN, not finite large errors

```python
import numpy as np
from solvers.spectral.cosine import CosineSpectral

r = np.linspace(0, 1, 51)
T0 = 1 - r**2
solver = CosineSpectral()

outcomes = {"stable": 0, "nan": 0, "inf": 0}

for alpha in [0.0, 0.5, 1.0, 1.5, 2.0]:
    T_hist = solver.solve(T0.copy(), r, 0.001, 0.1, alpha)
    if np.any(np.isnan(T_hist)):
        outcomes["nan"] += 1
    elif np.any(np.isinf(T_hist)):
        outcomes["inf"] += 1
    else:
        outcomes["stable"] += 1

print(outcomes)
```


### MEDIUM Priority

**[H3] Crank-Nicolson (FDM) is unconditionally stable for any α and dt**

Rationale: Implicit methods are A-stable for parabolic PDEs

Verification:
  1. Run FDM with very large dt (dt=0.01, 0.05)
  2. Verify solution remains bounded
  3. Compute stability factor vs spectral

Expected: FDM stable for all tested dt, spectral fails for large dt

```python
from solvers.fdm.implicit import ImplicitFDM
import numpy as np

r = np.linspace(0, 1, 51)
T0 = 1 - r**2
solver = ImplicitFDM()

for dt in [0.01, 0.02, 0.05]:
    T_hist = solver.solve(T0.copy(), r, dt, t_end=0.1, alpha=1.0)
    print(f"dt={dt}: max|T|={np.max(np.abs(T_hist)):.4f}")
```

**[H5] Spectral performs better when max|dT/dr| < 0.5 (below χ threshold)**

Rationale: Below threshold, χ=0.1 (constant) - linear problem favors spectral

Verification:
  1. Create IC with small gradients: T₀ = 0.2*(1-r²)
  2. Test both solvers in purely linear regime
  3. Compare accuracy and speed

Expected: Spectral wins when χ is constant (linear diffusion)

```python
import numpy as np
from solvers.fdm.implicit import ImplicitFDM
from solvers.spectral.cosine import CosineSpectral

r = np.linspace(0, 1, 51)
T0 = 0.2 * (1 - r**2)  # max|dT/dr| = 0.4 < 0.5

# Run both solvers
fdm = ImplicitFDM()
spectral = CosineSpectral()

T_fdm = fdm.solve(T0.copy(), r, 0.001, 0.1, alpha=0.0)
T_spec = spectral.solve(T0.copy(), r, 0.001, 0.1, alpha=0.0)

print(f"FDM final T[0]: {T_fdm[-1, 0]:.6f}")
print(f"Spectral final T[0]: {T_spec[-1, 0]:.6f}")
```

**[H6] With λ=1.0 (speed-focused), solver ranking may change**

Rationale: Current λ=0.1 heavily favors accuracy; higher λ may favor faster solver

Verification:
  1. Regenerate results with λ = 0.0, 0.1, 0.5, 1.0, 2.0
  2. Plot solver win rate vs λ
  3. Find crossover point

Expected: Higher λ may favor spectral (if faster) or reveal no change

```python
# Modify policy/select.py or use select_best with different lam
from policy.select import select_best

results = [
    {"name": "fdm", "l2_error": 0.01, "wall_time": 0.005},
    {"name": "spectral", "l2_error": 0.02, "wall_time": 0.002},
]

for lam in [0.0, 0.1, 0.5, 1.0, 2.0]:
    best = select_best(results, lam=lam)
    print(f"λ={lam}: best={best['name']}")
```

**[H9] 4x refinement for reference may be insufficient for high α**

Rationale: Nonlinear problems may need finer reference for accurate evaluation

Verification:
  1. Compute reference with 4x, 8x, 16x refinement
  2. Check convergence of reference solution
  3. Re-evaluate solver errors with refined reference

Expected: Higher refinement may change relative solver rankings

```python
import numpy as np
from solvers.fdm.implicit import ImplicitFDM

r = np.linspace(0, 1, 51)
T0 = 1 - r**2

for refine in [4, 8, 16]:
    nr_fine = refine * len(r) - (refine - 1)
    r_fine = np.linspace(0, 1, nr_fine)
    T0_fine = np.interp(r_fine, r, T0)
    dt_fine = 0.001 / refine

    solver = ImplicitFDM()
    T_ref = solver.solve(T0_fine, r_fine, dt_fine, 0.1, alpha=1.0)
    print(f"Refinement {refine}x: T_ref[0]={T_ref[-1, 0]:.6f}")
```


### LOW Priority

**[H8] Finer grid in (dt, nr) space reveals optimal spectral region**

Rationale: Current sweep is coarse (3×3); may miss sweet spots

Verification:
  1. Create finer sweep: nr ∈ [21, 31, 41, 51, 61, 71, 81]
  2. dt ∈ [0.0001, 0.0002, 0.0005, 0.001, 0.002]
  3. Generate heatmap of solver wins

Expected: Find parameter region where spectral is competitive

**[H10] A properly trained PINN could outperform both solvers for high α**

Rationale: PINNs can learn complex nonlinear dynamics without explicit discretization

Verification:
  1. Implement full PINN (not stub) with PyTorch
  2. Train on representative problems
  3. Compare accuracy and inference time

Expected: PINN may excel for strongly nonlinear cases (α > 1)


## Recommended Execution Order

1. **H7** - Classify spectral failures (NaN vs finite error)
2. **H1** - Test spectral stability with small dt
3. **H4** - Add new initial conditions
4. **H5** - Test below-threshold regime (linear)
5. **H6** - Vary cost function weight λ
6. **H2** - Investigate implicit spectral variant

======================================================================